# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package QREncode;
use base qw(Exporter);
use base qw(DynaLoader);
package QREncodec;
bootstrap QREncode;
package QREncode;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package QREncode;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package QREncode;


############# Class : QREncode::RS_BLOCKINFO ##############

package QREncode::RS_BLOCKINFO;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QREncode );
%OWNER = ();
%ITERATORS = ();
*swig_ncRSBlock_get = *QREncodec::RS_BLOCKINFO_ncRSBlock_get;
*swig_ncRSBlock_set = *QREncodec::RS_BLOCKINFO_ncRSBlock_set;
*swig_ncAllCodeWord_get = *QREncodec::RS_BLOCKINFO_ncAllCodeWord_get;
*swig_ncAllCodeWord_set = *QREncodec::RS_BLOCKINFO_ncAllCodeWord_set;
*swig_ncDataCodeWord_get = *QREncodec::RS_BLOCKINFO_ncDataCodeWord_get;
*swig_ncDataCodeWord_set = *QREncodec::RS_BLOCKINFO_ncDataCodeWord_set;
sub new {
    my $pkg = shift;
    my $self = QREncodec::new_RS_BLOCKINFO(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QREncodec::delete_RS_BLOCKINFO($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QREncode::QR_VERSIONINFO ##############

package QREncode::QR_VERSIONINFO;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QREncode );
%OWNER = ();
%ITERATORS = ();
*swig_nVersionNo_get = *QREncodec::QR_VERSIONINFO_nVersionNo_get;
*swig_nVersionNo_set = *QREncodec::QR_VERSIONINFO_nVersionNo_set;
*swig_ncAllCodeWord_get = *QREncodec::QR_VERSIONINFO_ncAllCodeWord_get;
*swig_ncAllCodeWord_set = *QREncodec::QR_VERSIONINFO_ncAllCodeWord_set;
*swig_ncDataCodeWord_get = *QREncodec::QR_VERSIONINFO_ncDataCodeWord_get;
*swig_ncDataCodeWord_set = *QREncodec::QR_VERSIONINFO_ncDataCodeWord_set;
*swig_ncAlignPoint_get = *QREncodec::QR_VERSIONINFO_ncAlignPoint_get;
*swig_ncAlignPoint_set = *QREncodec::QR_VERSIONINFO_ncAlignPoint_set;
*swig_nAlignPoint_get = *QREncodec::QR_VERSIONINFO_nAlignPoint_get;
*swig_nAlignPoint_set = *QREncodec::QR_VERSIONINFO_nAlignPoint_set;
*swig_RS_BlockInfo1_get = *QREncodec::QR_VERSIONINFO_RS_BlockInfo1_get;
*swig_RS_BlockInfo1_set = *QREncodec::QR_VERSIONINFO_RS_BlockInfo1_set;
*swig_RS_BlockInfo2_get = *QREncodec::QR_VERSIONINFO_RS_BlockInfo2_get;
*swig_RS_BlockInfo2_set = *QREncodec::QR_VERSIONINFO_RS_BlockInfo2_set;
sub new {
    my $pkg = shift;
    my $self = QREncodec::new_QR_VERSIONINFO(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QREncodec::delete_QR_VERSIONINFO($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QREncode::CQR_Encode ##############

package QREncode::CQR_Encode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QREncode );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QREncodec::new_CQR_Encode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QREncodec::delete_CQR_Encode($self);
        delete $OWNER{$self};
    }
}

*swig_m_nLevel_get = *QREncodec::CQR_Encode_m_nLevel_get;
*swig_m_nLevel_set = *QREncodec::CQR_Encode_m_nLevel_set;
*swig_m_nVersion_get = *QREncodec::CQR_Encode_m_nVersion_get;
*swig_m_nVersion_set = *QREncodec::CQR_Encode_m_nVersion_set;
*swig_m_bAutoExtent_get = *QREncodec::CQR_Encode_m_bAutoExtent_get;
*swig_m_bAutoExtent_set = *QREncodec::CQR_Encode_m_bAutoExtent_set;
*swig_m_nMaskingNo_get = *QREncodec::CQR_Encode_m_nMaskingNo_get;
*swig_m_nMaskingNo_set = *QREncodec::CQR_Encode_m_nMaskingNo_set;
*swig_m_nSymbleSize_get = *QREncodec::CQR_Encode_m_nSymbleSize_get;
*swig_m_nSymbleSize_set = *QREncodec::CQR_Encode_m_nSymbleSize_set;
*swig_m_byModuleData_get = *QREncodec::CQR_Encode_m_byModuleData_get;
*swig_m_byModuleData_set = *QREncodec::CQR_Encode_m_byModuleData_set;
*EncodeData = *QREncodec::CQR_Encode_EncodeData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package QREncode;

*QR_LEVEL_L = *QREncodec::QR_LEVEL_L;
*QR_LEVEL_M = *QREncodec::QR_LEVEL_M;
*QR_LEVEL_Q = *QREncodec::QR_LEVEL_Q;
*QR_LEVEL_H = *QREncodec::QR_LEVEL_H;
*QR_MODE_NUMERAL = *QREncodec::QR_MODE_NUMERAL;
*QR_MODE_ALPHABET = *QREncodec::QR_MODE_ALPHABET;
*QR_MODE_8BIT = *QREncodec::QR_MODE_8BIT;
*QR_MODE_KANJI = *QREncodec::QR_MODE_KANJI;
*QR_VRESION_S = *QREncodec::QR_VRESION_S;
*QR_VRESION_M = *QREncodec::QR_VRESION_M;
*QR_VRESION_L = *QREncodec::QR_VRESION_L;
*MAX_ALLCODEWORD = *QREncodec::MAX_ALLCODEWORD;
*MAX_DATACODEWORD = *QREncodec::MAX_DATACODEWORD;
*MAX_CODEBLOCK = *QREncodec::MAX_CODEBLOCK;
*MAX_MODULESIZE = *QREncodec::MAX_MODULESIZE;
*QR_MARGIN = *QREncodec::QR_MARGIN;
1;
