# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package SQR;
use base qw(Exporter);
use base qw(DynaLoader);
package SQRc;
bootstrap SQR;
package SQR;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package SQR;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package SQR;

*qdr_use_cairo_version = *SQRc::qdr_use_cairo_version;
*qdr_use_pikl_version = *SQRc::qdr_use_pikl_version;
*qdr_init = *SQRc::qdr_init;
*qdr_close = *SQRc::qdr_close;
*qdr_set_msize = *SQRc::qdr_set_msize;
*qdr_get_msize = *SQRc::qdr_get_msize;
*qdr_set_margin = *SQRc::qdr_set_margin;
*qdr_get_margin = *SQRc::qdr_get_margin;
*qdr_save = *SQRc::qdr_save;
*qdr_bg_color = *SQRc::qdr_bg_color;
*qdr_bg_image = *SQRc::qdr_bg_image;
*qdr_bg_grad = *SQRc::qdr_bg_grad;
*qdr_group = *SQRc::qdr_group;
*qdr_group_count = *SQRc::qdr_group_count;
*qdr_group_member_count = *SQRc::qdr_group_member_count;
*qdr_group_palette = *SQRc::qdr_group_palette;
*qdr_group_palette_rand = *SQRc::qdr_group_palette_rand;
*qdr_group_image = *SQRc::qdr_group_image;
*qdr_set_mark = *SQRc::qdr_set_mark;
*qdr_set_mark_color = *SQRc::qdr_set_mark_color;
*qdr_set_mark_grad = *SQRc::qdr_set_mark_grad;
*qdr_set_mark_image = *SQRc::qdr_set_mark_image;
*qdr_eye_outer_color = *SQRc::qdr_eye_outer_color;
*qdr_eye_inner_color = *SQRc::qdr_eye_inner_color;
*qdr_eye_image = *SQRc::qdr_eye_image;
*qdr_eye_outer_color_reset = *SQRc::qdr_eye_outer_color_reset;
*qdr_eye_inner_color_reset = *SQRc::qdr_eye_inner_color_reset;
*qdr_eye_image_reset = *SQRc::qdr_eye_image_reset;
*qdr_set_mark_shadow = *SQRc::qdr_set_mark_shadow;
*qdr_paste_layout = *SQRc::qdr_paste_layout;
*qdr_paste = *SQRc::qdr_paste;
*qdr_hole = *SQRc::qdr_hole;
*qdr_largest_width = *SQRc::qdr_largest_width;
*qdr_largest_height = *SQRc::qdr_largest_height;
*qdr_largest_x = *SQRc::qdr_largest_x;
*qdr_largest_y = *SQRc::qdr_largest_y;
*qdr_text = *SQRc::qdr_text;
*qdr_filter_invert = *SQRc::qdr_filter_invert;
*qdr_filter_crayon = *SQRc::qdr_filter_crayon;
*qdr_filter_circle = *SQRc::qdr_filter_circle;
*qdr_filter_grid = *SQRc::qdr_filter_grid;
*qdr_filter_voronoi = *SQRc::qdr_filter_voronoi;
*qdr_filter_dots = *SQRc::qdr_filter_dots;
*qdr_filter_hexagon = *SQRc::qdr_filter_hexagon;
*qdr_filter_diamond = *SQRc::qdr_filter_diamond;
*qdr_filter_tile = *SQRc::qdr_filter_tile;
*qdr_filter_noise = *SQRc::qdr_filter_noise;
*qdr_filter_hydrangea = *SQRc::qdr_filter_hydrangea;
*qdr_filter_wave = *SQRc::qdr_filter_wave;
*qdr_filter_ball = *SQRc::qdr_filter_ball;
*qdr_test = *SQRc::qdr_test;

############# Class : SQR::RS_BLOCKINFO ##############

package SQR::RS_BLOCKINFO;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_ncRSBlock_get = *SQRc::RS_BLOCKINFO_ncRSBlock_get;
*swig_ncRSBlock_set = *SQRc::RS_BLOCKINFO_ncRSBlock_set;
*swig_ncAllCodeWord_get = *SQRc::RS_BLOCKINFO_ncAllCodeWord_get;
*swig_ncAllCodeWord_set = *SQRc::RS_BLOCKINFO_ncAllCodeWord_set;
*swig_ncDataCodeWord_get = *SQRc::RS_BLOCKINFO_ncDataCodeWord_get;
*swig_ncDataCodeWord_set = *SQRc::RS_BLOCKINFO_ncDataCodeWord_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_RS_BLOCKINFO(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_RS_BLOCKINFO($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QR_VERSIONINFO ##############

package SQR::QR_VERSIONINFO;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_nVersionNo_get = *SQRc::QR_VERSIONINFO_nVersionNo_get;
*swig_nVersionNo_set = *SQRc::QR_VERSIONINFO_nVersionNo_set;
*swig_ncAllCodeWord_get = *SQRc::QR_VERSIONINFO_ncAllCodeWord_get;
*swig_ncAllCodeWord_set = *SQRc::QR_VERSIONINFO_ncAllCodeWord_set;
*swig_ncDataCodeWord_get = *SQRc::QR_VERSIONINFO_ncDataCodeWord_get;
*swig_ncDataCodeWord_set = *SQRc::QR_VERSIONINFO_ncDataCodeWord_set;
*swig_ncAlignPoint_get = *SQRc::QR_VERSIONINFO_ncAlignPoint_get;
*swig_ncAlignPoint_set = *SQRc::QR_VERSIONINFO_ncAlignPoint_set;
*swig_nAlignPoint_get = *SQRc::QR_VERSIONINFO_nAlignPoint_get;
*swig_nAlignPoint_set = *SQRc::QR_VERSIONINFO_nAlignPoint_set;
*swig_RS_BlockInfo1_get = *SQRc::QR_VERSIONINFO_RS_BlockInfo1_get;
*swig_RS_BlockInfo1_set = *SQRc::QR_VERSIONINFO_RS_BlockInfo1_set;
*swig_RS_BlockInfo2_get = *SQRc::QR_VERSIONINFO_RS_BlockInfo2_get;
*swig_RS_BlockInfo2_set = *SQRc::QR_VERSIONINFO_RS_BlockInfo2_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QR_VERSIONINFO(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QR_VERSIONINFO($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::CQR_Encode ##############

package SQR::CQR_Encode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = SQRc::new_CQR_Encode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_CQR_Encode($self);
        delete $OWNER{$self};
    }
}

*swig_m_nLevel_get = *SQRc::CQR_Encode_m_nLevel_get;
*swig_m_nLevel_set = *SQRc::CQR_Encode_m_nLevel_set;
*swig_m_nVersion_get = *SQRc::CQR_Encode_m_nVersion_get;
*swig_m_nVersion_set = *SQRc::CQR_Encode_m_nVersion_set;
*swig_m_bAutoExtent_get = *SQRc::CQR_Encode_m_bAutoExtent_get;
*swig_m_bAutoExtent_set = *SQRc::CQR_Encode_m_bAutoExtent_set;
*swig_m_nMaskingNo_get = *SQRc::CQR_Encode_m_nMaskingNo_get;
*swig_m_nMaskingNo_set = *SQRc::CQR_Encode_m_nMaskingNo_set;
*swig_m_nSymbleSize_get = *SQRc::CQR_Encode_m_nSymbleSize_get;
*swig_m_nSymbleSize_set = *SQRc::CQR_Encode_m_nSymbleSize_set;
*swig_m_byModuleData_get = *SQRc::CQR_Encode_m_byModuleData_get;
*swig_m_byModuleData_set = *SQRc::CQR_Encode_m_byModuleData_set;
*EncodeData = *SQRc::CQR_Encode_EncodeData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDRGroupAttr ##############

package SQR::QDRGroupAttr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_count_get = *SQRc::QDRGroupAttr_count_get;
*swig_count_set = *SQRc::QDRGroupAttr_count_set;
*swig_r_get = *SQRc::QDRGroupAttr_r_get;
*swig_r_set = *SQRc::QDRGroupAttr_r_set;
*swig_g_get = *SQRc::QDRGroupAttr_g_get;
*swig_g_set = *SQRc::QDRGroupAttr_g_set;
*swig_b_get = *SQRc::QDRGroupAttr_b_get;
*swig_b_set = *SQRc::QDRGroupAttr_b_set;
*swig_a_get = *SQRc::QDRGroupAttr_a_get;
*swig_a_set = *SQRc::QDRGroupAttr_a_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDRGroupAttr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDRGroupAttr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDRGroup ##############

package SQR::QDRGroup;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_data_get = *SQRc::QDRGroup_data_get;
*swig_data_set = *SQRc::QDRGroup_data_set;
*swig_count_get = *SQRc::QDRGroup_count_get;
*swig_count_set = *SQRc::QDRGroup_count_set;
*swig_attr_get = *SQRc::QDRGroup_attr_get;
*swig_attr_set = *SQRc::QDRGroup_attr_set;
*swig_image_get = *SQRc::QDRGroup_image_get;
*swig_image_set = *SQRc::QDRGroup_image_set;
*swig_is_mark_get = *SQRc::QDRGroup_is_mark_get;
*swig_is_mark_set = *SQRc::QDRGroup_is_mark_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDRGroup(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDRGroup($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDRGrad ##############

package SQR::QDRGrad;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::QDRGrad_type_get;
*swig_type_set = *SQRc::QDRGrad_type_set;
*swig_r0_get = *SQRc::QDRGrad_r0_get;
*swig_r0_set = *SQRc::QDRGrad_r0_set;
*swig_g0_get = *SQRc::QDRGrad_g0_get;
*swig_g0_set = *SQRc::QDRGrad_g0_set;
*swig_b0_get = *SQRc::QDRGrad_b0_get;
*swig_b0_set = *SQRc::QDRGrad_b0_set;
*swig_a0_get = *SQRc::QDRGrad_a0_get;
*swig_a0_set = *SQRc::QDRGrad_a0_set;
*swig_r1_get = *SQRc::QDRGrad_r1_get;
*swig_r1_set = *SQRc::QDRGrad_r1_set;
*swig_g1_get = *SQRc::QDRGrad_g1_get;
*swig_g1_set = *SQRc::QDRGrad_g1_set;
*swig_b1_get = *SQRc::QDRGrad_b1_get;
*swig_b1_set = *SQRc::QDRGrad_b1_set;
*swig_a1_get = *SQRc::QDRGrad_a1_get;
*swig_a1_set = *SQRc::QDRGrad_a1_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDRGrad(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDRGrad($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDREye ##############

package SQR::QDREye;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_enable_get = *SQRc::QDREye_enable_get;
*swig_enable_set = *SQRc::QDREye_enable_set;
*swig_r_get = *SQRc::QDREye_r_get;
*swig_r_set = *SQRc::QDREye_r_set;
*swig_g_get = *SQRc::QDREye_g_get;
*swig_g_set = *SQRc::QDREye_g_set;
*swig_b_get = *SQRc::QDREye_b_get;
*swig_b_set = *SQRc::QDREye_b_set;
*swig_a_get = *SQRc::QDREye_a_get;
*swig_a_set = *SQRc::QDREye_a_set;
*swig_image_get = *SQRc::QDREye_image_get;
*swig_image_set = *SQRc::QDREye_image_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDREye(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDREye($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDRRect ##############

package SQR::QDRRect;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_area_get = *SQRc::QDRRect_area_get;
*swig_area_set = *SQRc::QDRRect_area_set;
*swig_x_get = *SQRc::QDRRect_x_get;
*swig_x_set = *SQRc::QDRRect_x_set;
*swig_y_get = *SQRc::QDRRect_y_get;
*swig_y_set = *SQRc::QDRRect_y_set;
*swig_w_get = *SQRc::QDRRect_w_get;
*swig_w_set = *SQRc::QDRRect_w_set;
*swig_h_get = *SQRc::QDRRect_h_get;
*swig_h_set = *SQRc::QDRRect_h_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDRRect(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDRRect($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr ##############

package SQR::Qdr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_margin_get = *SQRc::Qdr_margin_get;
*swig_margin_set = *SQRc::Qdr_margin_set;
*swig_msize_get = *SQRc::Qdr_msize_get;
*swig_msize_set = *SQRc::Qdr_msize_set;
*swig_ssize_get = *SQRc::Qdr_ssize_get;
*swig_ssize_set = *SQRc::Qdr_ssize_set;
*swig_rsize_get = *SQRc::Qdr_rsize_get;
*swig_rsize_set = *SQRc::Qdr_rsize_set;
*swig_data_get = *SQRc::Qdr_data_get;
*swig_data_set = *SQRc::Qdr_data_set;
*swig_marktype_get = *SQRc::Qdr_marktype_get;
*swig_marktype_set = *SQRc::Qdr_marktype_set;
*swig_radius_get = *SQRc::Qdr_radius_get;
*swig_radius_set = *SQRc::Qdr_radius_set;
*swig_group_get = *SQRc::Qdr_group_get;
*swig_group_set = *SQRc::Qdr_group_set;
*swig_surface_get = *SQRc::Qdr_surface_get;
*swig_surface_set = *SQRc::Qdr_surface_set;
*swig_text_get = *SQRc::Qdr_text_get;
*swig_text_set = *SQRc::Qdr_text_set;
*swig_lr_get = *SQRc::Qdr_lr_get;
*swig_lr_set = *SQRc::Qdr_lr_set;
*swig_paste_get = *SQRc::Qdr_paste_get;
*swig_paste_set = *SQRc::Qdr_paste_set;
*swig_eyes_get = *SQRc::Qdr_eyes_get;
*swig_eyes_set = *SQRc::Qdr_eyes_set;
*swig_shadow_get = *SQRc::Qdr_shadow_get;
*swig_shadow_set = *SQRc::Qdr_shadow_set;
*swig_markpaint_get = *SQRc::Qdr_markpaint_get;
*swig_markpaint_set = *SQRc::Qdr_markpaint_set;
*swig_background_get = *SQRc::Qdr_background_get;
*swig_background_set = *SQRc::Qdr_background_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_text ##############

package SQR::Qdr_text;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_font_get = *SQRc::Qdr_text_font_get;
*swig_font_set = *SQRc::Qdr_text_font_set;
*swig_utf8_get = *SQRc::Qdr_text_utf8_get;
*swig_utf8_set = *SQRc::Qdr_text_utf8_set;
*swig_height_get = *SQRc::Qdr_text_height_get;
*swig_height_set = *SQRc::Qdr_text_height_set;
*swig_r_get = *SQRc::Qdr_text_r_get;
*swig_r_set = *SQRc::Qdr_text_r_set;
*swig_g_get = *SQRc::Qdr_text_g_get;
*swig_g_set = *SQRc::Qdr_text_g_set;
*swig_b_get = *SQRc::Qdr_text_b_get;
*swig_b_set = *SQRc::Qdr_text_b_set;
*swig_a_get = *SQRc::Qdr_text_a_get;
*swig_a_set = *SQRc::Qdr_text_a_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_text(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_text($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_lr ##############

package SQR::Qdr_lr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_searched_get = *SQRc::Qdr_lr_searched_get;
*swig_searched_set = *SQRc::Qdr_lr_searched_set;
*swig_rect_get = *SQRc::Qdr_lr_rect_get;
*swig_rect_set = *SQRc::Qdr_lr_rect_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_lr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_lr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_paste ##############

package SQR::Qdr_paste;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::Qdr_paste_type_get;
*swig_type_set = *SQRc::Qdr_paste_type_set;
*swig_image_get = *SQRc::Qdr_paste_image_get;
*swig_image_set = *SQRc::Qdr_paste_image_set;
*swig_layout_get = *SQRc::Qdr_paste_layout_get;
*swig_layout_set = *SQRc::Qdr_paste_layout_set;
*swig_level_get = *SQRc::Qdr_paste_level_get;
*swig_level_set = *SQRc::Qdr_paste_level_set;
*swig_x_get = *SQRc::Qdr_paste_x_get;
*swig_x_set = *SQRc::Qdr_paste_x_set;
*swig_y_get = *SQRc::Qdr_paste_y_get;
*swig_y_set = *SQRc::Qdr_paste_y_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_paste(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_paste($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_eyes ##############

package SQR::Qdr_eyes;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_data_get = *SQRc::Qdr_eyes_data_get;
*swig_data_set = *SQRc::Qdr_eyes_data_set;
*swig_eye_get = *SQRc::Qdr_eyes_eye_get;
*swig_eye_set = *SQRc::Qdr_eyes_eye_set;
*swig_lastcell_get = *SQRc::Qdr_eyes_lastcell_get;
*swig_lastcell_set = *SQRc::Qdr_eyes_lastcell_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_eyes(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_eyes($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_eyes_lastcell ##############

package SQR::Qdr_eyes_lastcell;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *SQRc::Qdr_eyes_lastcell_x_get;
*swig_x_set = *SQRc::Qdr_eyes_lastcell_x_set;
*swig_y_get = *SQRc::Qdr_eyes_lastcell_y_get;
*swig_y_set = *SQRc::Qdr_eyes_lastcell_y_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_eyes_lastcell(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_eyes_lastcell($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_shadow ##############

package SQR::Qdr_shadow;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_r_get = *SQRc::Qdr_shadow_r_get;
*swig_r_set = *SQRc::Qdr_shadow_r_set;
*swig_g_get = *SQRc::Qdr_shadow_g_get;
*swig_g_set = *SQRc::Qdr_shadow_g_set;
*swig_b_get = *SQRc::Qdr_shadow_b_get;
*swig_b_set = *SQRc::Qdr_shadow_b_set;
*swig_a_get = *SQRc::Qdr_shadow_a_get;
*swig_a_set = *SQRc::Qdr_shadow_a_set;
*swig_offsetx_get = *SQRc::Qdr_shadow_offsetx_get;
*swig_offsetx_set = *SQRc::Qdr_shadow_offsetx_set;
*swig_offsety_get = *SQRc::Qdr_shadow_offsety_get;
*swig_offsety_set = *SQRc::Qdr_shadow_offsety_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_shadow(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_shadow($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_markpaint ##############

package SQR::Qdr_markpaint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::Qdr_markpaint_type_get;
*swig_type_set = *SQRc::Qdr_markpaint_type_set;
*swig_r_get = *SQRc::Qdr_markpaint_r_get;
*swig_r_set = *SQRc::Qdr_markpaint_r_set;
*swig_g_get = *SQRc::Qdr_markpaint_g_get;
*swig_g_set = *SQRc::Qdr_markpaint_g_set;
*swig_b_get = *SQRc::Qdr_markpaint_b_get;
*swig_b_set = *SQRc::Qdr_markpaint_b_set;
*swig_a_get = *SQRc::Qdr_markpaint_a_get;
*swig_a_set = *SQRc::Qdr_markpaint_a_set;
*swig_image_get = *SQRc::Qdr_markpaint_image_get;
*swig_image_set = *SQRc::Qdr_markpaint_image_set;
*swig_grad_get = *SQRc::Qdr_markpaint_grad_get;
*swig_grad_set = *SQRc::Qdr_markpaint_grad_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_markpaint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_markpaint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_background ##############

package SQR::Qdr_background;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::Qdr_background_type_get;
*swig_type_set = *SQRc::Qdr_background_type_set;
*swig_r_get = *SQRc::Qdr_background_r_get;
*swig_r_set = *SQRc::Qdr_background_r_set;
*swig_g_get = *SQRc::Qdr_background_g_get;
*swig_g_set = *SQRc::Qdr_background_g_set;
*swig_b_get = *SQRc::Qdr_background_b_get;
*swig_b_set = *SQRc::Qdr_background_b_set;
*swig_a_get = *SQRc::Qdr_background_a_get;
*swig_a_set = *SQRc::Qdr_background_a_set;
*swig_image_get = *SQRc::Qdr_background_image_get;
*swig_image_set = *SQRc::Qdr_background_image_set;
*swig_grad_get = *SQRc::Qdr_background_grad_get;
*swig_grad_set = *SQRc::Qdr_background_grad_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_background(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_background($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package SQR;

*QR_LEVEL_L = *SQRc::QR_LEVEL_L;
*QR_LEVEL_M = *SQRc::QR_LEVEL_M;
*QR_LEVEL_Q = *SQRc::QR_LEVEL_Q;
*QR_LEVEL_H = *SQRc::QR_LEVEL_H;
*QR_MODE_NUMERAL = *SQRc::QR_MODE_NUMERAL;
*QR_MODE_ALPHABET = *SQRc::QR_MODE_ALPHABET;
*QR_MODE_8BIT = *SQRc::QR_MODE_8BIT;
*QR_MODE_KANJI = *SQRc::QR_MODE_KANJI;
*QR_VRESION_S = *SQRc::QR_VRESION_S;
*QR_VRESION_M = *SQRc::QR_VRESION_M;
*QR_VRESION_L = *SQRc::QR_VRESION_L;
*MAX_ALLCODEWORD = *SQRc::MAX_ALLCODEWORD;
*MAX_DATACODEWORD = *SQRc::MAX_DATACODEWORD;
*MAX_CODEBLOCK = *SQRc::MAX_CODEBLOCK;
*MAX_MODULESIZE = *SQRc::MAX_MODULESIZE;
*QR_MARGIN = *SQRc::QR_MARGIN;
*QDR_VERSION_MAJOR = *SQRc::QDR_VERSION_MAJOR;
*QDR_VERSION_MINOR = *SQRc::QDR_VERSION_MINOR;
*QDR_VERSION_MICRO = *SQRc::QDR_VERSION_MICRO;
*QDR_MAXMSIZE = *SQRc::QDR_MAXMSIZE;
*QDR_DEFAULT_MSIZE = *SQRc::QDR_DEFAULT_MSIZE;
*QDR_DEFAULT_MARGIN = *SQRc::QDR_DEFAULT_MARGIN;
*QDR_DEFAULT_RADIUS = *SQRc::QDR_DEFAULT_RADIUS;
*QDR_MARKTYPE_RECTANGLE = *SQRc::QDR_MARKTYPE_RECTANGLE;
*QDR_MARKTYPE_ARC = *SQRc::QDR_MARKTYPE_ARC;
*QDR_MARKTYPE_BLOCKARC = *SQRc::QDR_MARKTYPE_BLOCKARC;
*QDR_MARKTYPE_METABALL = *SQRc::QDR_MARKTYPE_METABALL;
*QDR_BACKGROUND_SIMPLE = *SQRc::QDR_BACKGROUND_SIMPLE;
*QDR_BACKGROUND_IMAGE = *SQRc::QDR_BACKGROUND_IMAGE;
*QDR_BACKGROUND_GRAD = *SQRc::QDR_BACKGROUND_GRAD;
*QDR_MARKPAINT_SIMPLE = *SQRc::QDR_MARKPAINT_SIMPLE;
*QDR_MARKPAINT_IMAGE = *SQRc::QDR_MARKPAINT_IMAGE;
*QDR_MARKPAINT_PALETTE = *SQRc::QDR_MARKPAINT_PALETTE;
*QDR_MARKPAINT_GRAD = *SQRc::QDR_MARKPAINT_GRAD;
*QDR_GRADIENT_L2R = *SQRc::QDR_GRADIENT_L2R;
*QDR_GRADIENT_T2B = *SQRc::QDR_GRADIENT_T2B;
*QDR_GRADIENT_TL2BR = *SQRc::QDR_GRADIENT_TL2BR;
*QDR_GRADIENT_BL2TR = *SQRc::QDR_GRADIENT_BL2TR;
*QDR_GRADIENT_RADIAL = *SQRc::QDR_GRADIENT_RADIAL;
*QDR_LAYOUT_UNSET = *SQRc::QDR_LAYOUT_UNSET;
*QDR_LAYOUT_NORTH = *SQRc::QDR_LAYOUT_NORTH;
*QDR_LAYOUT_SOUTH = *SQRc::QDR_LAYOUT_SOUTH;
*QDR_LAYOUT_EAST = *SQRc::QDR_LAYOUT_EAST;
*QDR_LAYOUT_WEST = *SQRc::QDR_LAYOUT_WEST;
*QDR_LAYOUT_CENTER = *SQRc::QDR_LAYOUT_CENTER;
*QDR_LEVEL_N = *SQRc::QDR_LEVEL_N;
*QDR_LEVEL_L = *SQRc::QDR_LEVEL_L;
*QDR_LEVEL_M = *SQRc::QDR_LEVEL_M;
*QDR_LEVEL_Q = *SQRc::QDR_LEVEL_Q;
*QDR_LEVEL_H = *SQRc::QDR_LEVEL_H;
*QDR_PASTETYPE_LAYOUT = *SQRc::QDR_PASTETYPE_LAYOUT;
*QDR_PASTETYPE_POSITION = *SQRc::QDR_PASTETYPE_POSITION;
*QDR_FORMAT_PNG = *SQRc::QDR_FORMAT_PNG;
*QDR_FORMAT_SVG = *SQRc::QDR_FORMAT_SVG;
*QDR_FORMAT_PDF = *SQRc::QDR_FORMAT_PDF;
1;


######################################################################
package SQR::LEVEL;
    use constant L => 0;
    use constant M => 1;
    use constant Q => 2;
    use constant H => 3;
1;

package SQR::VERSION;
    use constant S => 0;    #  1 -  9
    use constant M => 1;    # 10 - 26
    use constant L => 2;    # 27 - 40
1;

package SQR::GRADIENT;
	use constant L2R    => 0;
	use constant T2B    => 1;
	use constant TL2BR  => 2;
	use constant BL2TR  => 3;
	use constant RADIAL => 4;
1;

package SQR::MARKTYPE;
	use constant RECTANGLE => 0;
	use constant ARC       => 1;
	use constant BLOCKARC  => 2;
	use constant METABALL  => 3;
1;

package SQR::LAYOUT;
	use constant UNSET  => 0;
	use constant NORTH  => 1;
	use constant SOUTH  => 2;
	use constant EAST   => 3;
	use constant WEST   => 4;
	use constant CENTER => 5;
1;

package SQR::FORMAT;
	use constant PNG => 0;
	use constant SVG => 1;
	use constant PDF => 2;
1;

package SQR;
sub new {
    my ($pkg, $data, $level, $version, $ae, $mask) = @_;
    
    warn "data not found!" unless $data;
    $level   ||= SQR::LEVEL::M;
    $version ||= SQR::VERSION::S;
    $ae      ||= 1;
    $mask    ||= -1;
    
    my $p = SQR::CQR_Encode->new;
    warn "encode error." if $p->EncodeData($level, $version, $ae, $mask, $data, length $data)==true;
    
    my $qdr = SQR::Qdr->new;
    SQR::qdr_init($qdr, $p->swig_m_nSymbleSize_get, $p->swig_m_byModuleData_get);
    
    $p->DESTROY;
    
    my $this = bless {
        qdr   => $qdr,
        level => $level==SQR::LEVEL::M ? 15 :
                 $level==SQR::LEVEL::Q ? 25 :
                 $level==SQR::LEVEL::H ? 30 : 7,
    }, $pkg;
    
    $this;
}

sub msize {
    my ($this, $size) = @_;
    SQR::qdr_set_msize($this->{qdr}, $size);
}

sub margin {
    my ($this, $size) = @_;
    SQR::qdr_set_margin($this->{qdr}, $size);
}

sub size {
    my $this = shift;
    my $margin = $this->{qdr}->swig_margin_get;
    my $ssize = $this->{qdr}->swig_ssize_get;
    my $msize = $this->{qdr}->swig_msize_get;
    ($ssize + $margin * 2) * $msize;
}

sub save {
    my ($this, $name, $format) = @_;
    $format ||= SQR::FORMAT::PNG;
    SQR::qdr_save($this->{qdr}, $format, $name);
}

sub bg_color {
    my ($this, $r, $g, $b, $a) = @_;
    $a ||= 0xff;
    SQR::qdr_bg_color($this->{qdr}, $r, $g, $b, $a);
}

sub bg_image {
    my ($this, $file, $alpha) = @_;
    SQR::qdr_bg_image($this->{qdr}, $file, $alpha);
}

sub bg_grad {
    my ($this, $type, $r0, $g0, $b0, $a0, $r1, $g1, $b1, $a1) = @_;
    $a0 ||= 0xff;
    $a1 ||= 0xff;
    SQR::qdr_bg_grad($this->{qdr}, $type, $r0, $g0, $b0, $a0, $r1, $g1, $b1, $a1);
}

sub group {
    my $this = shift;
    SQR::qdr_group($this->{qdr});
}

sub group_count {
    my $this = shift;
    SQR::qdr_group_count($this->{qdr});
}

sub group_member_count {
    my ($this, $n) = @_;
    $n ||= 0;
    SQR::qdr_group_member_count($this->{qdr}, $n);
}

sub group_palette {
    my ($this, $n, $r, $g, $b, $a) = @_;
    $a ||= 0xff;
    SQR::qdr_group_palette($this->{qdr}, $n, $r, $g, $b, $a);
}

sub group_palette_rand {
    my ($this, $offset, $limit, $alpha) = @_;
    $offset = $offset<=0 ? 0 : $offset>=0xff ? 0xff : $offset;
    $limit  = $limit<=0 ? 0 : $limit>=0xff ? 0xff : $limit;
    $alpha ||= 0xff;
    SQR::qdr_group_palette_rand($this->{qdr}, $offset, $limit, $alpha);
}

sub group_image {
    my ($this, $file, $is_mark) = @_;
    SQR::qdr_group_image($this->{qdr}, $file, $is_mark);
}

#sub group_image_reset {
#    my ($this) = @_;
#    SQR::qdr_group_image($this->{qdr}, undef, 1);
#}

sub mark {
    my ($this, $type, $radius) = @_;
    $radius ||= 0.5;
    SQR::qdr_set_mark($this->{qdr}, $type, $radius);
}

sub mark_color {
    my ($this, $r, $g, $b, $a) = @_;
    $a ||= 0xff;
    SQR::qdr_set_mark_color($this->{qdr}, $r, $g, $b, $a);
}

sub mark_grad {
    my ($this, $type, $r0, $g0, $b0, $a0, $r1, $g1, $b1, $a1) = @_;
    $a0 ||= 0xff;
    $a1 ||= 0xff;
    SQR::qdr_set_mark_grad($this->{qdr}, $type, $r0, $g0, $b0, 0xff, $r1, $g1, $b1, 0xff);
}

sub mark_image {
    my ($this, $file, $alpha) = @_;
    SQR::qdr_set_mark_image($this->{qdr}, $file, $alpha);
}

sub eye_outer {
    my ($this, $index, $r, $g, $b, $a) = @_;
    $a ||= 0xff;
    SQR::qdr_eye_outer_color($this->{qdr}, $index, $r, $g, $b, $a);
}

sub eye_inner {
    my ($this, $index, $r, $g, $b, $a) = @_;
    $a ||= 0xff;
    SQR::qdr_eye_inner_color($this->{qdr}, $index, $r, $g, $b, $a);
}

sub eye_image {
    my ($this, $index, $file) = @_;
    SQR::qdr_eye_image($this->{qdr}, $index, $file);
}

sub shadow {
    my ($this, $ox, $oy, $r, $g, $b, $a) = @_;
    $a ||= 0xff;
    SQR::qdr_set_mark_shadow($this->{qdr}, $ox, $oy, $r, $g, $b, $a);
}

sub layout {
    my ($this, $file, $layout) = @_;
    SQR::qdr_paste_layout($this->{qdr}, $file, $layout, $this->{level});
}

sub paste {
    my ($this, $file, $x, $y) = @_;
    SQR::qdr_paste($this->{qdr}, $file, $x, $y);
}

sub hole {
    my $this = shift;
    SQR::qdr_hole($this->{qdr}, $this->{level});
}

sub largest_width {
    SQR::qdr_largest_width(shift->{qdr});
}

sub largest_height {
    SQR::qdr_largest_height(shift->{qdr});
}

sub largest_x {
    SQR::qdr_largest_x(shift->{qdr});
}

sub largest_y {
    SQR::qdr_largest_y(shift->{qdr});
}

sub text {
    my ($this, $font, $string, $height, $r, $g, $b, $a) = @_;
    $a ||= 0xff;
    SQR::qdr_text($this->{qdr}, $font, $string, $height, $r, $g, $b, $a);
}

sub filter_invert {
    SQR::qdr_filter_invert(shift->{qdr});
}

sub filter_crayon {
    my ($this, $factor, $bv1, $bv2, $alpha) = @_;
    SQR::qdr_filter_crayon($this->{qdr}, $factor, $bv1, $bv2, $alpha);
}

sub filter_noise {
    my ($this, $noise) = @_;
    SQR::qdr_filter_noise($this->{qdr}, $noise);
}

sub filter_circle {
    my ($this, $radius) = @_;
    SQR::qdr_filter_circle($this->{qdr}, $radius);
}

sub filter_grid {
    my ($this, $ms, $color) = @_;
    SQR::qdr_filter_grid($this->{qdr}, $ms, $color);
}

sub filter_voronoi {
    my ($this, $zone) = @_;
    SQR::qdr_filter_voronoi($this->{qdr}, $zone);
}

sub filter_dots {
    my ($this, $zone) = @_;
    SQR::qdr_filter_dots($this->{qdr}, $zone);
}

sub filter_hexagon {
    my ($this, $s) = @_;
    SQR::qdr_filter_hexagon($this->{qdr}, $s);
}

sub filter_diamond {
    my ($this, $s) = @_;
    SQR::qdr_filter_diamond($this->{qdr}, $s);
}

sub filter_tile {
    my ($this, $s) = @_;
    SQR::qdr_filter_tile($this->{qdr}, $s);
}

sub filter_hydrangea {
    my ($this, $n) = @_;
    SQR::qdr_filter_hydrangea($this->{qdr}, $n);
}

sub filter_wave {
    my ($this, $factor, $frequency) = @_;
    SQR::qdr_filter_wave($this->{qdr}, $factor, $frequency);
}

sub filter_ball {
    SQR::qdr_filter_ball(shift->{qdr});
}

sub DESTROY {
    my $this = shift;
    SQR::qdr_close($this->{qdr}) if($this->{qdr});
}

1;

