# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package SQR;
use base qw(Exporter);
use base qw(DynaLoader);
package SQRc;
bootstrap SQR;
package SQR;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package SQR;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package SQR;

*qdr_init = *SQRc::qdr_init;
*qdr_close = *SQRc::qdr_close;
*qdr_set_msize = *SQRc::qdr_set_msize;
*qdr_get_msize = *SQRc::qdr_get_msize;
*qdr_set_margin = *SQRc::qdr_set_margin;
*qdr_get_margin = *SQRc::qdr_get_margin;
*qdr_save = *SQRc::qdr_save;
*qdr_bg_color = *SQRc::qdr_bg_color;
*qdr_bg_image = *SQRc::qdr_bg_image;
*qdr_bg_grad = *SQRc::qdr_bg_grad;
*qdr_set_mark = *SQRc::qdr_set_mark;
*qdr_set_mark_color = *SQRc::qdr_set_mark_color;
*qdr_set_mark_grad = *SQRc::qdr_set_mark_grad;
*qdr_set_mark_image = *SQRc::qdr_set_mark_image;
*qdr_eye_outer_color = *SQRc::qdr_eye_outer_color;
*qdr_eye_inner_color = *SQRc::qdr_eye_inner_color;
*qdr_eye_image = *SQRc::qdr_eye_image;
*qdr_eye_outer_color_reset = *SQRc::qdr_eye_outer_color_reset;
*qdr_eye_inner_color_reset = *SQRc::qdr_eye_inner_color_reset;
*qdr_eye_image_reset = *SQRc::qdr_eye_image_reset;
*qdr_set_mark_shadow = *SQRc::qdr_set_mark_shadow;
*qdr_paste_layout = *SQRc::qdr_paste_layout;
*qdr_paste = *SQRc::qdr_paste;
*qdr_hole = *SQRc::qdr_hole;
*qdr_text = *SQRc::qdr_text;

############# Class : SQR::RS_BLOCKINFO ##############

package SQR::RS_BLOCKINFO;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_ncRSBlock_get = *SQRc::RS_BLOCKINFO_ncRSBlock_get;
*swig_ncRSBlock_set = *SQRc::RS_BLOCKINFO_ncRSBlock_set;
*swig_ncAllCodeWord_get = *SQRc::RS_BLOCKINFO_ncAllCodeWord_get;
*swig_ncAllCodeWord_set = *SQRc::RS_BLOCKINFO_ncAllCodeWord_set;
*swig_ncDataCodeWord_get = *SQRc::RS_BLOCKINFO_ncDataCodeWord_get;
*swig_ncDataCodeWord_set = *SQRc::RS_BLOCKINFO_ncDataCodeWord_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_RS_BLOCKINFO(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_RS_BLOCKINFO($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QR_VERSIONINFO ##############

package SQR::QR_VERSIONINFO;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_nVersionNo_get = *SQRc::QR_VERSIONINFO_nVersionNo_get;
*swig_nVersionNo_set = *SQRc::QR_VERSIONINFO_nVersionNo_set;
*swig_ncAllCodeWord_get = *SQRc::QR_VERSIONINFO_ncAllCodeWord_get;
*swig_ncAllCodeWord_set = *SQRc::QR_VERSIONINFO_ncAllCodeWord_set;
*swig_ncDataCodeWord_get = *SQRc::QR_VERSIONINFO_ncDataCodeWord_get;
*swig_ncDataCodeWord_set = *SQRc::QR_VERSIONINFO_ncDataCodeWord_set;
*swig_ncAlignPoint_get = *SQRc::QR_VERSIONINFO_ncAlignPoint_get;
*swig_ncAlignPoint_set = *SQRc::QR_VERSIONINFO_ncAlignPoint_set;
*swig_nAlignPoint_get = *SQRc::QR_VERSIONINFO_nAlignPoint_get;
*swig_nAlignPoint_set = *SQRc::QR_VERSIONINFO_nAlignPoint_set;
*swig_RS_BlockInfo1_get = *SQRc::QR_VERSIONINFO_RS_BlockInfo1_get;
*swig_RS_BlockInfo1_set = *SQRc::QR_VERSIONINFO_RS_BlockInfo1_set;
*swig_RS_BlockInfo2_get = *SQRc::QR_VERSIONINFO_RS_BlockInfo2_get;
*swig_RS_BlockInfo2_set = *SQRc::QR_VERSIONINFO_RS_BlockInfo2_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QR_VERSIONINFO(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QR_VERSIONINFO($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::CQR_Encode ##############

package SQR::CQR_Encode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = SQRc::new_CQR_Encode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_CQR_Encode($self);
        delete $OWNER{$self};
    }
}

*swig_m_nLevel_get = *SQRc::CQR_Encode_m_nLevel_get;
*swig_m_nLevel_set = *SQRc::CQR_Encode_m_nLevel_set;
*swig_m_nVersion_get = *SQRc::CQR_Encode_m_nVersion_get;
*swig_m_nVersion_set = *SQRc::CQR_Encode_m_nVersion_set;
*swig_m_bAutoExtent_get = *SQRc::CQR_Encode_m_bAutoExtent_get;
*swig_m_bAutoExtent_set = *SQRc::CQR_Encode_m_bAutoExtent_set;
*swig_m_nMaskingNo_get = *SQRc::CQR_Encode_m_nMaskingNo_get;
*swig_m_nMaskingNo_set = *SQRc::CQR_Encode_m_nMaskingNo_set;
*swig_m_nSymbleSize_get = *SQRc::CQR_Encode_m_nSymbleSize_get;
*swig_m_nSymbleSize_set = *SQRc::CQR_Encode_m_nSymbleSize_set;
*swig_m_byModuleData_get = *SQRc::CQR_Encode_m_byModuleData_get;
*swig_m_byModuleData_set = *SQRc::CQR_Encode_m_byModuleData_set;
*EncodeData = *SQRc::CQR_Encode_EncodeData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDRGrad ##############

package SQR::QDRGrad;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::QDRGrad_type_get;
*swig_type_set = *SQRc::QDRGrad_type_set;
*swig_r0_get = *SQRc::QDRGrad_r0_get;
*swig_r0_set = *SQRc::QDRGrad_r0_set;
*swig_g0_get = *SQRc::QDRGrad_g0_get;
*swig_g0_set = *SQRc::QDRGrad_g0_set;
*swig_b0_get = *SQRc::QDRGrad_b0_get;
*swig_b0_set = *SQRc::QDRGrad_b0_set;
*swig_a0_get = *SQRc::QDRGrad_a0_get;
*swig_a0_set = *SQRc::QDRGrad_a0_set;
*swig_r1_get = *SQRc::QDRGrad_r1_get;
*swig_r1_set = *SQRc::QDRGrad_r1_set;
*swig_g1_get = *SQRc::QDRGrad_g1_get;
*swig_g1_set = *SQRc::QDRGrad_g1_set;
*swig_b1_get = *SQRc::QDRGrad_b1_get;
*swig_b1_set = *SQRc::QDRGrad_b1_set;
*swig_a1_get = *SQRc::QDRGrad_a1_get;
*swig_a1_set = *SQRc::QDRGrad_a1_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDRGrad(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDRGrad($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDREye ##############

package SQR::QDREye;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_enable_get = *SQRc::QDREye_enable_get;
*swig_enable_set = *SQRc::QDREye_enable_set;
*swig_r_get = *SQRc::QDREye_r_get;
*swig_r_set = *SQRc::QDREye_r_set;
*swig_g_get = *SQRc::QDREye_g_get;
*swig_g_set = *SQRc::QDREye_g_set;
*swig_b_get = *SQRc::QDREye_b_get;
*swig_b_set = *SQRc::QDREye_b_set;
*swig_a_get = *SQRc::QDREye_a_get;
*swig_a_set = *SQRc::QDREye_a_set;
*swig_image_get = *SQRc::QDREye_image_get;
*swig_image_set = *SQRc::QDREye_image_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDREye(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDREye($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::QDRRect ##############

package SQR::QDRRect;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_area_get = *SQRc::QDRRect_area_get;
*swig_area_set = *SQRc::QDRRect_area_set;
*swig_x_get = *SQRc::QDRRect_x_get;
*swig_x_set = *SQRc::QDRRect_x_set;
*swig_y_get = *SQRc::QDRRect_y_get;
*swig_y_set = *SQRc::QDRRect_y_set;
*swig_w_get = *SQRc::QDRRect_w_get;
*swig_w_set = *SQRc::QDRRect_w_set;
*swig_h_get = *SQRc::QDRRect_h_get;
*swig_h_set = *SQRc::QDRRect_h_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_QDRRect(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_QDRRect($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr ##############

package SQR::Qdr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_margin_get = *SQRc::Qdr_margin_get;
*swig_margin_set = *SQRc::Qdr_margin_set;
*swig_msize_get = *SQRc::Qdr_msize_get;
*swig_msize_set = *SQRc::Qdr_msize_set;
*swig_ssize_get = *SQRc::Qdr_ssize_get;
*swig_ssize_set = *SQRc::Qdr_ssize_set;
*swig_rsize_get = *SQRc::Qdr_rsize_get;
*swig_rsize_set = *SQRc::Qdr_rsize_set;
*swig_data_get = *SQRc::Qdr_data_get;
*swig_data_set = *SQRc::Qdr_data_set;
*swig_marktype_get = *SQRc::Qdr_marktype_get;
*swig_marktype_set = *SQRc::Qdr_marktype_set;
*swig_radius_get = *SQRc::Qdr_radius_get;
*swig_radius_set = *SQRc::Qdr_radius_set;
*swig_surface_get = *SQRc::Qdr_surface_get;
*swig_surface_set = *SQRc::Qdr_surface_set;
*swig_text_get = *SQRc::Qdr_text_get;
*swig_text_set = *SQRc::Qdr_text_set;
*swig_lr_get = *SQRc::Qdr_lr_get;
*swig_lr_set = *SQRc::Qdr_lr_set;
*swig_paste_get = *SQRc::Qdr_paste_get;
*swig_paste_set = *SQRc::Qdr_paste_set;
*swig_eyes_get = *SQRc::Qdr_eyes_get;
*swig_eyes_set = *SQRc::Qdr_eyes_set;
*swig_shadow_get = *SQRc::Qdr_shadow_get;
*swig_shadow_set = *SQRc::Qdr_shadow_set;
*swig_markpaint_get = *SQRc::Qdr_markpaint_get;
*swig_markpaint_set = *SQRc::Qdr_markpaint_set;
*swig_background_get = *SQRc::Qdr_background_get;
*swig_background_set = *SQRc::Qdr_background_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_text ##############

package SQR::Qdr_text;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_font_get = *SQRc::Qdr_text_font_get;
*swig_font_set = *SQRc::Qdr_text_font_set;
*swig_utf8_get = *SQRc::Qdr_text_utf8_get;
*swig_utf8_set = *SQRc::Qdr_text_utf8_set;
*swig_height_get = *SQRc::Qdr_text_height_get;
*swig_height_set = *SQRc::Qdr_text_height_set;
*swig_r_get = *SQRc::Qdr_text_r_get;
*swig_r_set = *SQRc::Qdr_text_r_set;
*swig_g_get = *SQRc::Qdr_text_g_get;
*swig_g_set = *SQRc::Qdr_text_g_set;
*swig_b_get = *SQRc::Qdr_text_b_get;
*swig_b_set = *SQRc::Qdr_text_b_set;
*swig_a_get = *SQRc::Qdr_text_a_get;
*swig_a_set = *SQRc::Qdr_text_a_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_text(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_text($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_lr ##############

package SQR::Qdr_lr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_searched_get = *SQRc::Qdr_lr_searched_get;
*swig_searched_set = *SQRc::Qdr_lr_searched_set;
*swig_rect_get = *SQRc::Qdr_lr_rect_get;
*swig_rect_set = *SQRc::Qdr_lr_rect_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_lr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_lr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_paste ##############

package SQR::Qdr_paste;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::Qdr_paste_type_get;
*swig_type_set = *SQRc::Qdr_paste_type_set;
*swig_image_get = *SQRc::Qdr_paste_image_get;
*swig_image_set = *SQRc::Qdr_paste_image_set;
*swig_layout_get = *SQRc::Qdr_paste_layout_get;
*swig_layout_set = *SQRc::Qdr_paste_layout_set;
*swig_level_get = *SQRc::Qdr_paste_level_get;
*swig_level_set = *SQRc::Qdr_paste_level_set;
*swig_x_get = *SQRc::Qdr_paste_x_get;
*swig_x_set = *SQRc::Qdr_paste_x_set;
*swig_y_get = *SQRc::Qdr_paste_y_get;
*swig_y_set = *SQRc::Qdr_paste_y_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_paste(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_paste($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_eyes ##############

package SQR::Qdr_eyes;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_data_get = *SQRc::Qdr_eyes_data_get;
*swig_data_set = *SQRc::Qdr_eyes_data_set;
*swig_eye_get = *SQRc::Qdr_eyes_eye_get;
*swig_eye_set = *SQRc::Qdr_eyes_eye_set;
*swig_lastcell_get = *SQRc::Qdr_eyes_lastcell_get;
*swig_lastcell_set = *SQRc::Qdr_eyes_lastcell_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_eyes(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_eyes($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_eyes_lastcell ##############

package SQR::Qdr_eyes_lastcell;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *SQRc::Qdr_eyes_lastcell_x_get;
*swig_x_set = *SQRc::Qdr_eyes_lastcell_x_set;
*swig_y_get = *SQRc::Qdr_eyes_lastcell_y_get;
*swig_y_set = *SQRc::Qdr_eyes_lastcell_y_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_eyes_lastcell(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_eyes_lastcell($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_shadow ##############

package SQR::Qdr_shadow;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_r_get = *SQRc::Qdr_shadow_r_get;
*swig_r_set = *SQRc::Qdr_shadow_r_set;
*swig_g_get = *SQRc::Qdr_shadow_g_get;
*swig_g_set = *SQRc::Qdr_shadow_g_set;
*swig_b_get = *SQRc::Qdr_shadow_b_get;
*swig_b_set = *SQRc::Qdr_shadow_b_set;
*swig_a_get = *SQRc::Qdr_shadow_a_get;
*swig_a_set = *SQRc::Qdr_shadow_a_set;
*swig_offsetx_get = *SQRc::Qdr_shadow_offsetx_get;
*swig_offsetx_set = *SQRc::Qdr_shadow_offsetx_set;
*swig_offsety_get = *SQRc::Qdr_shadow_offsety_get;
*swig_offsety_set = *SQRc::Qdr_shadow_offsety_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_shadow(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_shadow($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_markpaint ##############

package SQR::Qdr_markpaint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::Qdr_markpaint_type_get;
*swig_type_set = *SQRc::Qdr_markpaint_type_set;
*swig_r_get = *SQRc::Qdr_markpaint_r_get;
*swig_r_set = *SQRc::Qdr_markpaint_r_set;
*swig_g_get = *SQRc::Qdr_markpaint_g_get;
*swig_g_set = *SQRc::Qdr_markpaint_g_set;
*swig_b_get = *SQRc::Qdr_markpaint_b_get;
*swig_b_set = *SQRc::Qdr_markpaint_b_set;
*swig_a_get = *SQRc::Qdr_markpaint_a_get;
*swig_a_set = *SQRc::Qdr_markpaint_a_set;
*swig_image_get = *SQRc::Qdr_markpaint_image_get;
*swig_image_set = *SQRc::Qdr_markpaint_image_set;
*swig_grad_get = *SQRc::Qdr_markpaint_grad_get;
*swig_grad_set = *SQRc::Qdr_markpaint_grad_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_markpaint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_markpaint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : SQR::Qdr_background ##############

package SQR::Qdr_background;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( SQR );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *SQRc::Qdr_background_type_get;
*swig_type_set = *SQRc::Qdr_background_type_set;
*swig_r_get = *SQRc::Qdr_background_r_get;
*swig_r_set = *SQRc::Qdr_background_r_set;
*swig_g_get = *SQRc::Qdr_background_g_get;
*swig_g_set = *SQRc::Qdr_background_g_set;
*swig_b_get = *SQRc::Qdr_background_b_get;
*swig_b_set = *SQRc::Qdr_background_b_set;
*swig_a_get = *SQRc::Qdr_background_a_get;
*swig_a_set = *SQRc::Qdr_background_a_set;
*swig_image_get = *SQRc::Qdr_background_image_get;
*swig_image_set = *SQRc::Qdr_background_image_set;
*swig_grad_get = *SQRc::Qdr_background_grad_get;
*swig_grad_set = *SQRc::Qdr_background_grad_set;
sub new {
    my $pkg = shift;
    my $self = SQRc::new_Qdr_background(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        SQRc::delete_Qdr_background($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package SQR;

*QR_LEVEL_L = *SQRc::QR_LEVEL_L;
*QR_LEVEL_M = *SQRc::QR_LEVEL_M;
*QR_LEVEL_Q = *SQRc::QR_LEVEL_Q;
*QR_LEVEL_H = *SQRc::QR_LEVEL_H;
*QR_MODE_NUMERAL = *SQRc::QR_MODE_NUMERAL;
*QR_MODE_ALPHABET = *SQRc::QR_MODE_ALPHABET;
*QR_MODE_8BIT = *SQRc::QR_MODE_8BIT;
*QR_MODE_KANJI = *SQRc::QR_MODE_KANJI;
*QR_VRESION_S = *SQRc::QR_VRESION_S;
*QR_VRESION_M = *SQRc::QR_VRESION_M;
*QR_VRESION_L = *SQRc::QR_VRESION_L;
*MAX_ALLCODEWORD = *SQRc::MAX_ALLCODEWORD;
*MAX_DATACODEWORD = *SQRc::MAX_DATACODEWORD;
*MAX_CODEBLOCK = *SQRc::MAX_CODEBLOCK;
*MAX_MODULESIZE = *SQRc::MAX_MODULESIZE;
*QR_MARGIN = *SQRc::QR_MARGIN;
*QDR_VERSION_MAJOR = *SQRc::QDR_VERSION_MAJOR;
*QDR_VERSION_MINOR = *SQRc::QDR_VERSION_MINOR;
*QDR_VERSION_MICRO = *SQRc::QDR_VERSION_MICRO;
*QDR_MAXMSIZE = *SQRc::QDR_MAXMSIZE;
*QDR_DEFAULT_MSIZE = *SQRc::QDR_DEFAULT_MSIZE;
*QDR_DEFAULT_MARGIN = *SQRc::QDR_DEFAULT_MARGIN;
*QDR_DEFAULT_RADIUS = *SQRc::QDR_DEFAULT_RADIUS;
*QDR_MARKTYPE_RECTANGLE = *SQRc::QDR_MARKTYPE_RECTANGLE;
*QDR_MARKTYPE_ARC = *SQRc::QDR_MARKTYPE_ARC;
*QDR_MARKTYPE_BLOCKARC = *SQRc::QDR_MARKTYPE_BLOCKARC;
*QDR_MARKTYPE_METABALL = *SQRc::QDR_MARKTYPE_METABALL;
*QDR_BACKGROUND_SIMPLE = *SQRc::QDR_BACKGROUND_SIMPLE;
*QDR_BACKGROUND_IMAGE = *SQRc::QDR_BACKGROUND_IMAGE;
*QDR_BACKGROUND_GRAD = *SQRc::QDR_BACKGROUND_GRAD;
*QDR_MARKPAINT_SIMPLE = *SQRc::QDR_MARKPAINT_SIMPLE;
*QDR_MARKPAINT_IMAGE = *SQRc::QDR_MARKPAINT_IMAGE;
*QDR_MARKPAINT_PALETTE = *SQRc::QDR_MARKPAINT_PALETTE;
*QDR_MARKPAINT_GRAD = *SQRc::QDR_MARKPAINT_GRAD;
*QDR_GRADIENT_L2R = *SQRc::QDR_GRADIENT_L2R;
*QDR_GRADIENT_T2B = *SQRc::QDR_GRADIENT_T2B;
*QDR_GRADIENT_TL2BR = *SQRc::QDR_GRADIENT_TL2BR;
*QDR_GRADIENT_BL2TR = *SQRc::QDR_GRADIENT_BL2TR;
*QDR_GRADIENT_RADIAL = *SQRc::QDR_GRADIENT_RADIAL;
*QDR_LAYOUT_UNSET = *SQRc::QDR_LAYOUT_UNSET;
*QDR_LAYOUT_NORTH = *SQRc::QDR_LAYOUT_NORTH;
*QDR_LAYOUT_SOUTH = *SQRc::QDR_LAYOUT_SOUTH;
*QDR_LAYOUT_EAST = *SQRc::QDR_LAYOUT_EAST;
*QDR_LAYOUT_WEST = *SQRc::QDR_LAYOUT_WEST;
*QDR_LAYOUT_CENTER = *SQRc::QDR_LAYOUT_CENTER;
*QDR_LEVEL_N = *SQRc::QDR_LEVEL_N;
*QDR_LEVEL_L = *SQRc::QDR_LEVEL_L;
*QDR_LEVEL_M = *SQRc::QDR_LEVEL_M;
*QDR_LEVEL_Q = *SQRc::QDR_LEVEL_Q;
*QDR_LEVEL_H = *SQRc::QDR_LEVEL_H;
*QDR_PASTETYPE_LAYOUT = *SQRc::QDR_PASTETYPE_LAYOUT;
*QDR_PASTETYPE_POSITION = *SQRc::QDR_PASTETYPE_POSITION;
*QDR_FORMAT_PNG = *SQRc::QDR_FORMAT_PNG;
1;
